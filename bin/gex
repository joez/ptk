#!/usr/bin/env perl
# author: joe.zheng

use strict;
use warnings;

use FindBin;
use lib "$FindBin::RealBin/../lib";

use Excel::Writer::XLSX;
use Excel::Writer::XLSX::Utility;

use XML::Reader qw/XML::Parsepp/;
use XML::Writer;

use Encode qw/decode/;
use Encode::Guess;

use Git::Repository 'Log';

use Getopt::Long;
use File::Path qw/make_path/;
use File::Basename;
use File::Spec::Functions qw/catdir catfile rel2abs/;
use File::Find 'find';
use File::Temp qw/tempdir/;
use Storable qw/nstore retrieve/;
use Text::ParseWords;
use Digest::MD5 qw/md5_hex/;

use Parallel::ForkManager;

use Ptk::Base::Log;
use Ptk::Base::Chdir;
use Ptk::Gex::Manifest;
use Ptk::Base::Executor;

my $log = Ptk::Base::Log->new;

my $script = basename($0);

sub usage {
  print <<"EOF";
NAME
    $script - Manage the Git repos

SYNOPSIS
    $script report-log [<options>] [<src>...]
    $script report-delta [<options>] <this> <that> [<src>...]
    $script report-manifest [<options>] [<src>...]

    $script forall [<options>] [<src>...]
    $script tag-manifest [<options>] <tag> [<src>...]
    $script format-patch [<options>] [<src>...]
    $script match-cherry [<options>] <this> <that> [<src>...]

    $script overlay-manifest [<options>] <this> <that> [<src>...]

    $script find-repo [<src>...]
    $script dump-repo [<options>] [<src>...]

DESCRIPTION
    To manage the Git repos

COMMAND
    $script report-log [-r <root>] [-o <output>] [-q <query>] [-j <jobs>]
    [<src>...]
      export Git log into spreadsheet
      <query>:  the parameters passed to "git log"
      <output>: spreadsheet file path, default "log.xlsx"
      <src>:    relative git repo paths

    $script report-delta [-r <root>] [-o <output>] [-b <base>] [-j <jobs>]
    <this> <that> [<src>...]
      export commit list need to be integrated from <that> to <this>
      as an spreadsheet
      <output>: spreadsheet file path, default "delta.xlsx"
      <base>:   up to and including <base> are not reported on <that>
      <this>:   working branch
      <that>:   remote branch, mostly upstream
      <src>:    relative Git repo paths

    $script report-manifest [-u <url>] [-m <manifest>] [-o <output>]
    [-j <jobs>] [-q <query>] [<src>...]
      export manifest information into spreadsheet
      <query>:    same as in "dump-repo"
      <output>:   spreadsheet file path, default "manifest.xlsx"
      <src>:      manifest branches, default as HEAD

    $script forall [-r <root>] [-u <url>] [-m <manifest>] [-j <jobs>]
    [-c <command>] [<src>...]
      run the same shell command in each repo, with cwd as current
      repo's work tree, environment variables are set:
       * REPO_PROJECT:  the name of the project
       * REPO_PATH:     the path of the project
       * REPO_REMOTE:   the name of the remote
       * REPO_LREV:     the revision translated for local usage
       * REPO_RREV:     the revision from the manifest
       * REPO_GROUPS:   the groups from the manifest if exists
       * REPO_UPSTREAM: the upstream from the manifest if exists
      <command>:  command to run, default is "git status"
      <src>:      relative Git repo paths

    $script tag-manifest [-r <root>] [-u <url>] [-m <manifest>] [-j <jobs>]
    <tag> [<src>...]
      add a tag for each repo given the revision from the manifest
      <url>:      manifest repo url, default ".repo/manifests"
      <tag>:      tag name to apply
      <src>:      relative Git repo paths

    $script format-patch [-r <root>] [-q <query>] [-o <output>] [<src>...]
      format-patch for each repo into output directory
      <query>:   the parameters for "git format-patch", default is "-1",
                 if it is a file, will be regarded as a commit list, with
                 the format:
                  * text start with "#" regarded as comment
                  * text end with ":" regarded as repo path for the
                    following commits
                  * one commit id for each line with ordered
      <output>:  the output directory, default is "./patch"
      <src>:     relative Git repo paths

    $script match-cherry [-r <root>] [-j <jobs>] <this> <that> [<src>...]
      find out all the original and picked cherries with the same changeset
      (with same patch id), but different commit ids between two branches
      <this>: working branch
      <that>: remote branch, mostly upstream
      <src>:  relative Git repo paths

    $script overlay-manifest [-f <field>] <this> <that> [<src>...]
      overlay each Git repo's fields defined in <this> manifest by
      one defined in <that> manifest, generally <that> manifest is a
      snapshot, by this way to pin some Git repo in a stable revision
      <field>: fields to apply, joined by ",", default is "revision"
      <this>:  the target manifest
      <that>:  the snapshot manifest to be applied
      <src>:   the Git repo paths or names

    $script find-repo [<src>...]
      find valid Git repo in the <src> directories and output the paths,
      it can be used to get the Git repo path list for later usage
      <src>: directories to search, default is "."

    $script dump-repo [-q <query>] [<src>...]
      dump the Git repo paths in the given manifests
      <query>: dump repo matching the query only, the query format is
        queries separated by ',', each query is a key-value pair
        separeated by ':', the key is the attribute of the repo definition
        and the value is a regex to match. e.g. "revision:master"
        prefix with '!' for negative match, e.g. "!group:aosp,path:vendor"
      <src>:   manifests to dump, default is ".repo/manifests/default.xml"

OPTIONS

    -r, --root
      the root directory of the Git repo path, default is "."
      all the Git repo paths are assumed relative to the root

    -u, --url
      the manifest repo url, default is ".repo/manifests"

    -m, --manifest
      the alternative manifest file to use, default is "default.xml"

    -j, --jobs
      concurrent jobs to run, default is 2

    -o, --output
      the output file path

    <src>
      the source files or directories

EXAMPLES
    1. $script report-log Ptk
      export all the commit list of "Ptk" to "log.xlsx"

    2. $script dump-repo
      dump all the git repo paths in the default manifest at
      ".repo/manifests/default.xml"

    3. $script dump-repo -q 'groups:device,revision:master' default.xml
      dump all the git repo paths in the default manifest "default.xml"
      with "groups" matches "device" AND "revision" matches "master"

    4. $script dump-repo | xargs $script report-log -o all.xlsx
      export all the commits of repos in default manifest to "all.xlsx"

    5. $script find-repo > repo-list.txt
      find out all the valid Git repo paths in the current directory
      and redirect to repo-list.txt for later usage

    6. $script report-log -j 4 -q 'develop..upstream' repo-list.txt
      export the commits between "develop" and "upsteam" branches,
      for the Git repos in the "repo-list.txt", and export to "log.xlsx"
	  with maximal concurrent 4 jobs

    7. $script forall Ptk
      run "git status" in Git repo "Ptk"

    8. $script forall -c 'git pull --rebase' repo-list.txt
      run "git pull --rebase" in Git repos in "repo-list.txt"

    9. $script match-cherry develop upstream repo-list.txt
      find all the commit with same changeset but different commit id,
      between "develop" and "upstream" of Git repos in "repo-list.txt"

    10. $script report-delta develop upstream repo-list.txt
      export all the commit list only exist in the "upstream" branch of
      Git repos in "repo-list.txt" into "delta.xlsx", these commits
      need to be cherry-picked

    11. $script format-patch -j 4 -q BASE..HEAD repo-list.txt
      format-patch from BASE to HEAD for each repo in repo-list.txt,
      save the patches into "./patch" folder

    12. $script format-patch -q commit-list.txt -o exported-patch
      export the patch according to the definition in the commit-list.txt
      save the patches into "exported-patch" folder

    13. $script overlay-manifest default.xml snapshot.xml repo-list.txt
      overlay repo's revision defined in default.xml by one defined in
      snapshot.xml, only the repo name in "repo-list.txt" is applied

    14. $script tag-manifest -u . -m pin.xml TAG_FOR_TEST repo-list.txt
      add a tag named TAG_FOR_TEST for each repo listed in repo-list.txt
      based on the revision defined from pin.xml

NOTES
    * all the Git repo paths are assumed relative to the root,
      if a path pointing to a existing file, it will be regarded as a
      file containing a path list

SEE ALSO

EOF

  exit;
}

my %opt = (
  root     => '.',
  query    => '',
  field    => '',
  base     => '',
  url      => '.repo/manifests',
  manifest => 'default.xml',
  jobs     => 2,
  output   => '',
  command  => ''
);

my $help;
GetOptions(
  "help|h"       => \$help,
  "root|r=s"     => \$opt{root},
  "query|q=s"    => \$opt{query},
  "field|f=s"    => \$opt{field},
  "base|b=s"     => \$opt{base},
  "url|u=s"      => \$opt{url},
  "manifest|m=s" => \$opt{manifest},
  "jobs|j=i"     => \$opt{jobs},
  "command|c=s"  => \$opt{command},
  "output|o=s"   => \$opt{output},
) or usage();

my $cmd = lc(shift || '');
usage() if $help || !$cmd;

my %cmdcbs = (
  "report-log"       => \&do_report_log,
  "report-delta"     => \&do_report_delta,
  "report-manifest"  => \&do_report_manifest,
  "find-repo"        => \&do_find_repo,
  "dump-repo"        => \&do_dump_repo,
  "match-cherry"     => \&do_match_cherry,
  "forall"           => \&do_forall,
  "tag-manifest"     => \&do_tag_manifest,
  "format-patch"     => \&do_format_patch,
  "overlay-manifest" => \&do_overlay_manifest,
);

my $cb = $cmdcbs{$cmd};
if ($cb) {
  $cb->(@ARGV);
}
else {
  warn 'no such command';
  usage();
}


# subs


sub resolve_list {
  my @list;

  foreach my $p (@_) {
    if (-e $p && -f $p) {
      open my $fh, '<', $p or die;
      while (<$fh>) {
        chomp;
        s/#.*//;
        s/^\s+//;
        s/\s+$//;
        next unless $_;

        push @list, $_;
      }
      close $fh;
    }
    else {
      push @list, $p;
    }
  }

  # remove trailing slash
  return map { s|/+$|| if $_ ne '/'; $_ } @list;
}

sub resolve_path {
  wantarray ? map { catfile($opt{root}, $_) } @_ : catfile($opt{root}, shift);
}

sub correct_sheet_name {
  my $n = shift;
  if (length $n) {

    # no more than 31, and no special chars
    if (length $n > 31) {
      $n = join('-', substr(md5_hex($n), -4), substr($n, -26));
    }
    $n =~ s|[\[\]\*\?:/\\]|.|g;
  }
  return $n;
}

sub correct_var_name {
  my $n = shift;
  $n =~ s/^\d+//;
  $n =~ s/[^0-9a-zA-Z]/_/g;
  return join('', map { +ucfirst } split(/_+/, $n));
}

sub get_temp_dir { return tempdir(CLEANUP => 1) }

sub checkout_to {
  my $dir = shift or die;
  my $url = shift or die;
  my $rev = shift || '';

  my $git_dir = catfile($dir, '.git');
  Git::Repository->run(qw/clone --mirror -s/, $url, $git_dir);

  my $r = Git::Repository->new(git_dir => $git_dir, work_tree => $dir);
  return $r->run(qw/reset --hard/, $rev);
}

sub do_report_manifest {
  my @revs = @_;
  unshift @revs, 'HEAD' unless @revs;

  my $dst      = $opt{output} || 'manifest.xlsx';
  my $url      = $opt{url};
  my $manifest = $opt{manifest};
  my $query    = $opt{query};

  my $db = {};
  $db->{meta}{$_} = {} for qw/path remote fetch review revs/;
  $db->{meta}{info}{query}    = $query;
  $db->{meta}{info}{manifest} = $manifest;
  $db->{meta}{info}{revision} = join ', ', @revs;

  for my $rev (@revs) {
    $log->info("processing: $rev");

    my $dir = get_temp_dir();
    checkout_to($dir, $url, $rev);

    my $f = catfile($dir, $manifest);
    my $m = Ptk::Gex::Manifest->new($f);
    for my $n ($m->list_project_names($query)) {
      my $r = $m->get_resolved_project($n);
      my $p = $r->{path};
      $db->{data}{$rev}{$p} = $r;

      $db->{meta}{$_}{$r->{$_}}++ for qw/path remote fetch review/;
    }
    $db->{meta}{revs}{$rev}++ if exists $db->{data}{$rev};
  }

  for my $rev (keys %{$db->{meta}{revs}}) {
    for my $p (keys %{$db->{meta}{path}}) {
      $db->{revision}{$p}{$rev} = '';
      if (exists $db->{data}{$rev} && exists $db->{data}{$rev}{$p}) {
        $db->{revision}{$p}{$rev} = $db->{data}{$rev}{$p}{revision};
      }
    }
  }

  repo_to_xls($dst, $db);
}

sub repo_to_xls {
  my $dst = shift or die;
  my $db  = shift or die;

  my @revs       = sort keys %{$db->{meta}{revs}};
  my @sheets     = (@revs, qw/summary revision meta/);
  my %sheet_name = map { ($_, $_) } @sheets;
  my %sheet_need = map { ($_, 1) } @sheets;

  $sheet_need{revision} = @revs > 1;

  my $workbook = Excel::Writer::XLSX->new($dst);
  my $bold     = $workbook->add_format(bold => 1, align => 'center');
  my $green    = $workbook->add_format(bg_color => '#A4D050');
  my ($sheet, $worksheet);
  my ($row,   $col);
  my (@head,  @width);

  my $SN = sub { correct_sheet_name($sheet_name{$_[0]}) };
  my $TN = sub { 'Tb' . correct_var_name($SN->($_[0])) };
  my $NEW_SHEET = sub {
    ($row, $col) = (0, 0);
    $worksheet = $workbook->add_worksheet($SN->($sheet));
    $worksheet->freeze_panes(1, 0);
    $worksheet->set_column($_, $_, $width[$_]) for 0 .. $#width;
    $worksheet->write_row($row++, 0, \@head, $bold);
  };
  my $NEW_TABLE = sub {
    my $n = $TN->($sheet);
    my @c = map { +{header => $_} } @head;

    $worksheet->add_table(0, 0, $row > 1 ? $row - 1 : 1,
      $#head, {style => 'Table Style Light 1', columns => \@c, name => $n,});
  };

  my $NEED = sub { $sheet_need{+shift} };

  # "revision" worksheet
  if ($NEED->($sheet = "revision")) {
    my @info = (qw/Path/, @revs);
    @head = (@info, qw/Note/);
    @width = (40, ((30) x @revs), 20);
    my %fields;
    @fields{@info} = @info;
    $fields{Path} = 'path';

    my %head_idx;
    {
      my $i;
      %head_idx = map +($_, $i++), @head;
    }

    $NEW_SHEET->();

    for my $p (sort keys %{$db->{meta}{path}}) {
      my %d = %{$db->{revision}{$p}};
      $d{path} = $p;

      my @l = @d{@fields{@info}};
      eval { $worksheet->write_row($row++, 0, \@l) };
    }

    $NEW_TABLE->();
  }

  # "summary" worksheet
  if ($NEED->($sheet = "summary")) {
    $worksheet = $workbook->add_worksheet($SN->($sheet));
  }

  for my $rev (@revs) {
    if ($NEED->($sheet = $rev)) {
      my @info = qw/Path Revision Name Fetch Review Groups/;
      @head = (@info, qw/Note/);
      @width = (40, 30, 30, 30, 30, 20, 20);
      my %fields;
      @fields{@info} = qw/path revision name fetch review groups/;
      my %head_idx;
      {
        my $i;
        %head_idx = map +($_, $i++), @head;
      }

      $NEW_SHEET->();

      foreach my $p (sort keys %{$db->{data}{$rev}}) {
        my %d = %{$db->{data}{$rev}{$p}};

        my @l = @d{@fields{@info}};
        eval { $worksheet->write_row($row++, 0, \@l) };
      }

      $NEW_TABLE->();
    }
  }

  # "meta" worksheet
  if ($NEED->($sheet = "meta")) {
    @head
      = qw/Status Priorities Repos Remotes Fetches Reviews Parameters Values/;
    @width = (10, 10, 40, 10, 30, 30, 20, 20);

    my %defs = (
      map({ $_, [] } @head),
      Status     => [sort qw/Todo Doing Done Redo Defer Ignore/],
      Priorities => [sort qw/Low Normal High/],
    );

    $defs{Repos}   = [sort keys %{$db->{meta}{path}}];
    $defs{Remotes} = [sort keys %{$db->{meta}{remote}}];
    $defs{Fetches} = [sort keys %{$db->{meta}{fetch}}];
    $defs{Reviews} = [sort keys %{$db->{meta}{review}}];
    for my $k (sort keys %{$db->{meta}{info}}) {
      push @{$defs{Values}},     $db->{meta}{info}{$k};
      push @{$defs{Parameters}}, $k;
    }

    $NEW_SHEET->();
    foreach (@head) {
      $workbook->define_name($_,
        xl_range_formula($SN->($sheet), $row, scalar @{$defs{$_}}, $col, $col)
      );
      $worksheet->write_col($row, $col++, $defs{$_});
    }
  }
}

sub do_find_repo {
  my @dirs = @_;
  unshift @dirs, '.' unless @dirs;

  my %seen;

  my $sub_wanted = sub {
    if (-d $_) {
      if (/\.git$/ || -e catfile($_, '.git')) {
        $seen{$File::Find::name}++;
        $File::Find::prune = 1;
        $log->info($File::Find::name);
      }
    }
  };
  my $sub_preprocess = sub {
    return grep { /^\.git$/ || !/^\./ } @_;
  };

  find({wanted => $sub_wanted, preprocess => $sub_preprocess}, $_)
    foreach @dirs;

  local $\ = "\n";
  print $_ foreach sort keys %seen;
}

sub do_dump_repo {
  my @manifests = @_;
  unshift @manifests, catfile(@opt{qw/url manifest/}) unless @manifests;

  my $query = $opt{query} || '';

  local $\ = "\n";
  for my $f (@manifests) {
    my $m = Ptk::Gex::Manifest->new($f);
    print $_ for sort +$m->list_project_paths($query);
  }
}

sub get_local_rev {
  my $rev = shift or die;
  my $remote = shift || '';

  for ($rev) {
    unless (/^HEAD$/ or m|^refs/| or /^[0-9a-f]{40}$/) {
      $rev = join('/', length $remote ? $remote : 'origin', $rev);
    }
  }
  return $rev;
}

sub do_forall {
  my $cmd = $opt{command} || 'git status';
  my @repos = resolve_list(@_);

  my $m;
  my $manifest = catfile(@opt{qw/url manifest/});
  if (-e $manifest) {
    $m = Ptk::Gex::Manifest->new($manifest);
  }
  else {
    $log->warn("can't access manifest: $manifest");
  }

  my $process = sub {
    my $idx  = shift;
    my $ctx  = shift;
    my $repo = shift;
    my $exit = shift;

    my $cnt = $idx + 1;
    my $ttl = $ctx->{ttl};
    my $log = $ctx->{log};

    my $exit_code = -1;

    $log->info("[$cnt / $ttl] processing: $repo");
    print "#-- project: $repo\n";

    my $path    = resolve_path($repo);
    my $git_dir = $path =~ /\.git$/ ? '.' : '.git';
    my $env     = {GIT_DIR => $git_dir, REPO_PATH => $repo};

    if ($m) {
      if (my $d = $m->get_resolved_project($repo)) {
        $env->{REPO_PROJECT} = $d->{name};
        $env->{REPO_REMOTE}  = $d->{remote};
        $env->{REPO_RREV}    = $d->{revision};
        $env->{REPO_LREV}
          = get_local_rev($d->{revision}, $d->{remote} || $d->{alias});
        $env->{REPO_GROUPS}   = $d->{groups}   if exists $d->{groups};
        $env->{REPO_UPSTREAM} = $d->{upstream} if exists $d->{upstream};
      }
      else {
        $log->warn("can't find repo in manifest: $repo");
      }
    }
    $log->debug($env);

    my $chdir = Ptk::Base::Chdir->new;
    unless ($chdir->pushd($path)) {
      $log->warn("fail to access $path, skip: $repo");
    }
    else {
      local %ENV = (%ENV, %$env);

      if (system($cmd)) {
        $log->warn("fail to process: $repo");
      }
      else {
        $exit_code = 0;
      }
    }

    $exit->($exit_code);
  };

  my $on_finish = sub {
    my ($idx, $ctx, $exit_code) = @_;
    $ctx->{fail}{$idx}++ if $exit_code;
  };

  my $ctx = {fail => {}, ttl => scalar(@repos), log => $log,};

  Ptk::Base::Executor->new(
    log       => $log,
    workers   => $opt{jobs},
    command   => $process,
    context   => $ctx,
    on_finish => $on_finish,
  )->execute(@repos);

  print <<EOF;
#-- DONE
Total @{[ scalar @repos ]} projects processed
EOF

  my @fail = map { $repos[$_] } keys %{$ctx->{fail}};
  print 'Total ', scalar @fail, ' projects are failed:', "\n";
  print join("\n", @fail), "\n";
}

sub do_tag_manifest {
  my $name = shift or usage();

  # hack here
  $opt{command} = "git tag $name \$REPO_LREV";

  do_forall(@_);
}

sub parse_commit_list {
  my %db;

  my $re_id  = qr/^([\da-f]{6,40})\b/;
  my $re_dir = qr/^\[?(.+?)\]?:$/;

  my $dir = '.';
  foreach my $p (@_) {
    if (-e $p && -f $p) {
      open my $fh, '<', $p or die;
      while (<$fh>) {
        chomp;
        s/#.*//;
        s/^\s+//;
        s/\s+$//;
        next unless $_;

        if (/$re_dir/) {
          $dir = $1;
        }
        elsif (/$re_id/) {
          $db{$dir}{data}{$1} = $_;
          push @{$db{$dir}{id}}, $1;
        }
      }
      close $fh;
    }
    else {
      $log->warn("can not accesss, skip: $p");
    }
  }

  return \%db;
}

sub save_apply_patch_script {
  my $path = shift || 'apply-patch';

  $log->info("generate script for applying patch: $path");
  if (-e $path) {
    $log->warn("file already exists, skip: $path");
  }
  else {
    my $dir = dirname($path);
    make_path($dir) unless -e $dir;
    open my $fh, '>', $path or die;

    print $fh <<'EOF';
#!/usr/bin/env perl
# author: joe.zheng

use strict;
use warnings;

use File::Path qw/make_path/;
use File::Basename;
use File::Copy;
use File::Spec::Functions qw/catdir catfile abs2rel rel2abs/;
use File::Find qw/find/;

my $self = abs2rel(dirname($0));

my $root = shift || catdir($self, 'exported');
my $work = shift || '.';
my $back = shift || catdir($self, 'imported');

print qq/# apply patches from "$root" to "$work", move to "$back" if success\n/;

my %todo;

my $wanted = sub { push @{$todo{$File::Find::dir}}, $_ if /\.patch$/ };
find({wanted => $wanted, preprocess => sub {grep { !/^\./ } @_}}, $root);

local $\ = "\n";
for my $p (sort keys %todo) {
  my $d = abs2rel($p, $root);
  my $repo = catdir($work, $d);
  die "fail to access: $repo\n" unless -e $repo;

  for my $f (sort @{$todo{$p}}) {
    my $patch = catfile($p, $f);

    print "\n# applying patch: $patch";

    if (system("cd $repo && git am -k -3 --whitespace=nowarn " . rel2abs($patch)) == 0) {
      my $d = catdir($back, $d);
      make_path($d) unless -e $d;
      move($patch, catfile($d, $f)) or die "fail to move $patch to $d\n";
    }
    else {
      die "fail to apply patch: $patch\n"
    }
  }
}

print "\n# done";
EOF

    close $fh;
    chmod 0755, $path;
  }
}

sub do_format_patch {
  my $output = $opt{output} || 'patch';
  my $query  = $opt{query}  || '-1';
  my @repos  = resolve_list(@_);
  my $root   = $opt{root}   || '.';

  # if the query is a file, regard it as commit list
  my $db;
  if (-e $query && -f $query) {
    $log->info("commit list: $query");
    $db = parse_commit_list($query);

    # if no repos provided, export all repos in commit list
    push @repos, sort keys %$db unless @repos;
  }

  # save script first
  save_apply_patch_script(catfile($output, 'apply-patch')) if @repos;

  my $process = sub {
    my $idx  = shift;
    my $ctx  = shift;
    my $repo = shift;
    my $exit = shift;

    my $cnt = $idx + 1;
    my $ttl = $ctx->{ttl};
    my $log = $ctx->{log};
    my $db  = $ctx->{db};

    $log->info("[$cnt / $ttl] processing: $repo");

    # standard output sub-folder: exported
    my $source = catdir($root, $repo);
    my $target = rel2abs(catdir($output, 'exported', $repo));

    unless (-e $source) {
      $log->warn("not exist, skip: $source");
      $exit->(-1);
    }
    else {
      $log->info("output: $target");
      make_path($target) unless -e $target;

      my $git_dir = $source;
      for ($git_dir) {
        $git_dir = catdir($git_dir, '.git') unless /\.git$/;
      }
      my $r = Git::Repository->new(git_dir => $git_dir);

      if ($db) {
        if (exists $db->{$repo}) {
          my $i = 1;
          for my $id (@{$db->{$repo}{id}}) {
            $log->info('processing: ' . $db->{$repo}{data}{$id});
            print "$_\n"
              for $r->run('format-patch', '-o', $target, '-k',
              '--start-number', $i++, '-1', $id);
          }
        }
        else {
          $log->warn("not defined in commit list, skip: $source");
          $exit->(-1);
        }
      }
      else {
        print "$_\n" for $r->run('format-patch', '-o', $target, '-k', $query);
      }
    }
  };

  my $on_finish = sub {
    my ($idx, $ctx, $exit_code) = @_;
    $ctx->{fail}{$idx}++ if $exit_code;
  };

  my $ctx = {db => $db, ttl => scalar(@repos), log => $log, fail => {},};

  Ptk::Base::Executor->new(
    log       => $log,
    workers   => $opt{jobs},
    command   => $process,
    context   => $ctx,
    on_finish => $on_finish,
  )->execute(@repos);

  print <<EOF;
#-- DONE
Total @{[ scalar @repos ]} projects processed
EOF

  my @fail = map { $repos[$_] } keys %{$ctx->{fail}};
  print 'Total ', scalar @fail, ' projects are failed:', "\n";
  print join("\n", @fail), "\n";
}

sub do_overlay_manifest {
  my $this = shift or die;
  die "cannot write file: $this" unless -w $this;
  my $that = shift or die;
  die "cannot read file: $that" unless -r $that;

  my $field = $opt{field} || 'revision';
  my @fields = split /,/, $field;

  my %wanted = map { ($_ => 1) } resolve_list(@_);

  my $ma = Ptk::Gex::Manifest->new($this);
  my $mb = Ptk::Gex::Manifest->new($that);

  local @ARGV = ($this, @{$ma->include});
  local $^I = '';
  while (<>) {
    if (/<project/ && /name="([^"]+?)"/) {
      if (my $d = $mb->get_resolved_project($1)) {
        my ($n, $p) = @{$d}{qw/name path/};

        # both name and path are accepted
        if ($wanted{$n} || $wanted{$p}) {
          $log->info("overlay $n");
          for my $k (@fields) {
            my $v = $d->{$k};
            next unless $v;

            $log->debug(qq/$k to "$v"/);
            unless (s/$k="(?:[^"]*?)"/$k="$v"/) {
              s|\s*?(/?>)\s*?$| $k="$v" $1|;
            }
          }
        }
      }
    }
    print;
  }
}

sub check_match_cherry {
  my $dr   = shift;    # { id => {} }
  my $this = shift;
  my $that = shift;
  my $factor = shift || [qw/patch_id change_id origin_id ticket_id subject/];

  my $repo;
  my $o = {data => [],};

  for my $id (keys %$dr) {
    my $d = $dr->{$id};
    my $s = $d->{branch};

    $repo = $d->{repo} unless $repo;

    push @{$o->{change_id}{$_}{$s}}, $id for @{$d->{change_ids}};
    push @{$o->{origin_id}{$_}{$s}}, $id for @{$d->{origin_ids}};
    push @{$o->{ticket_id}{$_}{$s}}, $id for @{$d->{ticket_ids}};
    for (qw/patch_id subject/) {
      push @{$o->{$_}{$d->{$_}}{$s}}, $id if $d->{$_};
    }
  }

  my %seen;

  for my $reason (@$factor) {
    next unless exists $o->{$reason};

    for my $id (keys %{$o->{$reason}}) {
      my $r = $o->{$reason}{$id};

      if ($reason eq 'origin_id') {
        if (exists $dr->{$id}) {
          my $swap = $dr->{$id}{branch} eq $that;
          my $other = $swap ? $this : $that;

          my $a = $id;
          if (exists $r->{$other}) {
            for (@{$r->{$other}}) {
              my $b = $_;
              my $ab = $swap ? $b . $a : $a . $b;

              next if exists $seen{$ab};
              $seen{$ab}++;

              push @{$o->{data}},
                {
                repo => $repo,
                $this => $swap ? $b : $a,
                $that => $swap ? $a : $b,
                reason => $reason,
                factor => $id,
                };
            }
          }
        }
      }

      if (exists $r->{$this} && exists $r->{$that}) {
        for my $a (@{$r->{$this}}) {
          for my $b (@{$r->{$that}}) {
            my $ab = $a . $b;
            next if exists $seen{$ab};
            $seen{$ab}++;
            push @{$o->{data}},
              {
              repo   => $repo,
              $this  => $a,
              $that  => $b,
              reason => $reason,
              factor => $id,
              };
          }
        }
      }
    }
  }

  return $o;
}

sub do_match_cherry {
  my $this = shift or usage();
  my $that = shift or usage();

  my $db    = {};
  my @repos = resolve_list(@_);

  my $process = sub {
    my $idx  = shift;
    my $ctx  = shift;
    my $repo = shift;
    my $exit = shift;

    my $cnt = $idx + 1;
    my $ttl = $ctx->{ttl};
    my $log = $ctx->{log};

    $log->info("[$cnt / $ttl] processing: $repo");

    my $path = resolve_path($repo);
    unless (-e $path) {
      $log->warn("can't access path: $path");
      $exit->(-1);
    }

    $path = catdir($path, '.git') unless $path =~ /\.git$/;

    my $data = {repo => $repo};

    my $r = Git::Repository->new(git_dir => $path);
    my $a = $r->run(qw/rev-parse --verify/, $this);
    my $b = $r->run(qw/rev-parse --verify/, $that);

    for ($r->run(qw/rev-list --no-merges --left-right/, "$a...$b")) {
      $log->debug($_);
      my $side = substr($_, 0, 1) eq '<' ? $this : $that;
      my $id = substr $_, 1;

      my $d = get_commit_info(git_log($r, "-1", $id)->next);
      $d->{branch} = $side;
      $d->{repo}   = $repo;

      # compare patch-id
      $d->{patch_id} = get_patch_id($r, $id);

      $data->{data}{$id} = $d;
    }
    $exit->(0, $data);
  };

  my $on_finish = sub {
    my ($idx, $ctx, $exit_code, $data) = @_;
    if (!$exit_code && $data) {
      my $repo = $data->{repo};
      $ctx->{db}{$repo} = $data->{data};
    }
  };

  my $ctx = {db => $db, ttl => scalar(@repos), log => $log,};

  Ptk::Base::Executor->new(
    log       => $log,
    workers   => $opt{jobs},
    command   => $process,
    context   => $ctx,
    on_finish => $on_finish,
  )->execute(@repos);

  local $\ = "\n";
  my $sep = "\t";
  my @head = ('Repo', $this, $that, 'Reason', 'Factor');
  my %fields;
  @fields{@head} = ('repo', $this, $that, 'reason', 'factor');

  print join($sep, @head);

  for my $repo (sort keys %$db) {
    my $dr = $db->{$repo};

    my $m = check_match_cherry($dr, $this, $that);
    for my $d (@{$m->{data}}) {
      print join($sep, @{$d}{@fields{@head}});
    }
  }
}

sub do_report_log {
  my $dst = $opt{output} || 'log.xlsx';

  my @repos = resolve_list(@_);

  my $db = {};
  $db->{meta}{refs}{query} = $opt{query};

  my $process = sub {
    my $idx  = shift;
    my $ctx  = shift;
    my $repo = shift;
    my $exit = shift;

    my $cnt = $idx + 1;
    my $ttl = $ctx->{ttl};
    my $log = $ctx->{log};

    $log->info("[$cnt / $ttl] processing: $repo");

    my $path = resolve_path($repo);
    unless (-e $path) {
      $log->warn("can't access path: $path");
      $exit->(-1);
    }

    my $data = parse_repo_log($path, $repo);
    $exit->(0, $data);
  };

  my $on_finish = sub {
    my ($idx, $ctx, $exit_code, $data) = @_;
    if (!$exit_code && $data) {
      my $repo = $data->{repo};
      $ctx->{db}{data}{$repo} = $data->{data};
    }
  };

  my $ctx = {db => $db, ttl => scalar(@repos), log => $log,};

  Ptk::Base::Executor->new(
    log       => $log,
    workers   => $opt{jobs},
    command   => $process,
    context   => $ctx,
    on_finish => $on_finish,
  )->execute(@repos);

  db_to_xls($dst, $db);
}

sub do_report_delta {
  my $this = shift or usage();
  my $that = shift or usage();

  my @repos = resolve_list(@_);
  my $base  = $opt{base};
  my $dst   = $opt{output} || 'delta.xlsx';

  my $db = {};
  $db->{meta}{refs}{base} = $base;
  $db->{meta}{refs}{this} = $this;
  $db->{meta}{refs}{that} = $that;

  my $process = sub {
    my $idx  = shift;
    my $ctx  = shift;
    my $repo = shift;
    my $exit = shift;

    my $cnt = $idx + 1;
    my $ttl = $ctx->{ttl};
    my $log = $ctx->{log};

    $log->info("[$cnt / $ttl] processing: $repo");

    my $path = resolve_path($repo);
    unless (-e $path) {
      $log->warn("can't access path: $path");
      $exit->(-1);
    }

    my $data = parse_repo_delta($path, $repo, $this, $that, $base);
    $exit->(0, $data);
  };

  my $on_finish = sub {
    my ($idx, $ctx, $exit_code, $data) = @_;
    if (!$exit_code && $data) {
      my $repo = $data->{repo};
      $ctx->{db}{$_}{$repo} = $data->{$_} for qw/data match/;
    }
  };

  my $ctx = {db => $db, ttl => scalar(@repos), log => $log,};

  Ptk::Base::Executor->new(
    log       => $log,
    workers   => $opt{jobs},
    command   => $process,
    context   => $ctx,
    on_finish => $on_finish,
  )->execute(@repos);

  db_to_xls($dst, $db);
}

sub parse_repo_log {
  my $path = shift or die;
  my $repo = shift or die;
  my $query = $opt{query} || '--';

  my $db = {repo => $repo};

  for ($path) {
    $path = catdir($path, '.git') unless /\.git$/;
  }
  eval {
    my $r = Git::Repository->new(git_dir => $path);
    my $i = git_log($r, shellwords $opt{query});

    $log->info($path, $opt{query});
    while (my $l = $i->next) {
      my $d = get_commit_info($l);
      $d->{repo} = $repo;
      $log->info($d->{commit});

      push @{$db->{data}{id}}, $d->{commit};
      $db->{data}{data}{$d->{commit}} = $d;
    }
  };

  return $db;
}

sub get_patch_id {
  my $repo = shift;
  my $id   = shift;

  my $cmd = $repo->command('patch-id');
  my $fi  = $cmd->stdin;
  my $fo  = $cmd->stdout;

  my $fd = $repo->command('show', $id)->stdout;
  while (<$fd>) {
    print $fi $_;
  }
  close $fi;
  close $fd;

  my $patch_id = (split ' ', <$fo>)[0];
  $cmd->close;

  return $patch_id;
}


sub parse_commit_message {
  my $m = shift;
  my $d = {};

  foreach (split "\n", $m) {
    chomp;
    next unless $_;

    # previous value may be overriden, just get the latest one
    if (/^Change-Id:\s+(I[\da-f]{40})$/) {
      push @{$d->{change_ids}}, $1;
      $d->{change_id} = $1;
      next;
    }
    if (/^Reviewed-on:\s+.+\/(\d+)$/) {
      push @{$d->{request_ids}}, $1;
      $d->{request_id} = $1;
      next;
    }
    if (/^\(cherry picked from commit ([\da-f]{40})$/) {
      push @{$d->{origin_ids}}, $1;
      $d->{origin_id} = $1;
      next;
    }

    if (/^Reviewed-by:\s+[^<]+<(([^@]+)@[\w.]+)>$/) {
      push @{$d->{reviewers}}, $1 unless $2 =~ /_noreply/;
      next;
    }

    if (/^(?:BZ):\s*([\d\s]+)$/) {
      for (split /\s/, $1) {
        if (/(\d+)/) {
          push @{$d->{ticket_ids}}, $1;
        }
      }
      next;
    }

    if (/^(?:Bug|Issue|UTP-Id):\s*(.+)$/) {
      for (split /\s/, $1) {
        if (/([A-Z-]*\d+)/) {
          push @{$d->{ticket_ids}}, $1;
        }
      }
      next;
    }

  }

  $log->debug($d);

  return $d;
}

sub parse_commit_extra {
  my $m = shift;
  my $d = {};

  foreach (split "\n", $m) {
    chomp;
    next unless $_;

    # files and status, see git log --name-status
    if (/^([ACDMRTUXB]+)\s+(.+)$/) {
      $d->{name_status}{$2} = $1;
    }
  }

  $log->debug($d);

  return $d;
}

sub git_log { shift->log('--name-status' => @_) }

sub get_commit_info {
  my $l = shift;

  my $d = {};
  $d = {
    commit          => $l->commit,
    author_name     => $l->author_name,
    author_email    => $l->author_email,
    author_time     => $l->author_localtime,
    committer_name  => $l->committer_name,
    committer_email => $l->committer_email,
    committer_time  => $l->committer_localtime,
    subject         => $l->subject,
    body            => $l->body,
    %{parse_commit_message($l->body)}, %{parse_commit_extra($l->extra)},
    }
    if $l;

  return $d;
}

sub parse_repo_delta {
  my $path = shift or die;
  my $repo = shift or die;
  my $this = shift or die;
  my $that = shift or die;
  my $base = shift || '';

  my $db = {repo => $repo};

  for ($path) {
    $path = catdir($path, '.git') unless /\.git$/;
  }
  eval {
    my $r = Git::Repository->new(git_dir => $path);
    $log->info($path, $this, $that);
    my $m = {};

    for ($r->run(shellwords "cherry $this $that $base")) {
      if (/^\+\s*(.+)$/) {
        my $id = $1;

        $log->info($id);

        my $d = get_commit_info(git_log($r, "-1", $id)->next);
        $d->{repo}   = $repo;
        $d->{branch} = $that;

        push @{$db->{data}{id}}, $id;
        $db->{data}{data}{$id} = $d;

        $m->{$id} = $d;
      }
    }

    for ($r->run(qw/rev-list --no-merges --left-only/, "$this...$that")) {
      my $id = $_;

      my $d = get_commit_info(git_log($r, "-1", $id)->next);
      $d->{branch} = $this;
      $d->{repo}   = $repo;

      $m->{$id} = $d;
    }

    my $f = [qw/change_id origin_id ticket_id subject/];
    $db->{match} = check_match_cherry($m, $this, $that, $f);
  };

  return $db;
}

sub format_date {
  my ($sec, $min, $hour, $mday, $mon, $year) = localtime(shift);
  return sprintf '%04d-%02d-%02d', $year + 1900, $mon + 1, $mday;
}

sub db_to_xls {
  my $dst = shift or die;
  my $db  = shift or die;

  my @sheets     = qw/data summary file ticket reviewer match repo meta/;
  my %sheet_name = map { ($_, $_) } @sheets;
  my %sheet_need = map { ($_, 1) } @sheets;

  $sheet_need{match} = exists $db->{match};

  my %author_email;
  my %id_ticket;
  my %id_reviewer;
  my $name_match = 'MatchedCherries';

  my $workbook = Excel::Writer::XLSX->new($dst);
  my $bold     = $workbook->add_format(bold => 1, align => 'center');
  my $green    = $workbook->add_format(bg_color => '#A4D050');
  my ($sheet, $worksheet);
  my ($row,   $col);
  my (@head,  @width);

  my $SN = sub { correct_sheet_name($sheet_name{$_[0]}) };
  my $TN = sub { 'Tb' . correct_var_name($SN->($_[0])) };
  my $NEW_SHEET = sub {
    ($row, $col) = (0, 0);
    $worksheet = $workbook->add_worksheet($SN->($sheet));
    $worksheet->freeze_panes(1, 0);
    $worksheet->set_column($_, $_, $width[$_]) for 0 .. $#width;
    $worksheet->write_row($row++, 0, \@head, $bold);
  };
  my $NEW_TABLE = sub {
    my $n = $TN->($sheet);
    my @c = map { +{header => $_} } @head;

    $worksheet->add_table(0, 0, $row > 1 ? $row - 1 : 1,
      $#head, {style => 'Table Style Light 1', columns => \@c, name => $n,});
  };

  my $NEED = sub { $sheet_need{+shift} };

  # "data" worksheet
  if ($NEED->($sheet = "data")) {
    my @info = qw/ID Author Email Subject Repo Committer Date Gerrit/;
    @head = (@info, qw/System Status Type Owner Team Note/);
    @width = (42, 14, 24, 56, 40, 14, 10, 8, 8, 8, 8, 14, 8, 18);
    my %fields;
    @fields{@info}
      = qw/commit author_name author_email subject repo committer_name committer_time request_id/;
    my %head_idx;
    {
      my $i;
      %head_idx = map +($_, $i++), @head;
    }

    $NEW_SHEET->();

    foreach my $repo (sort keys %{$db->{data}}) {
      foreach my $id (@{$db->{data}{$repo}{id}}) {
        my %d = %{$db->{data}{$repo}{data}{$id}};

        $author_email{$d{author_email}} = $d{author_name};
        for (@{$d{ticket_ids}}) {
          my $l = join ',', $id, $_;
          $id_ticket{$l}++;
        }
        for (@{$d{reviewers}}) {
          my $l = join ',', $id, $_;
          $id_reviewer{$l}++;
        }

        $d{committer_time} = format_date($d{committer_time});
        my @l = @d{@fields{@info}};
        eval { $worksheet->write_row($row++, 0, \@l) };
      }
    }

    my %field_to_defs = (Status => 'Status', Type => 'Types');
    foreach (qw/Status Type/) {
      $worksheet->data_validation(1, $head_idx{$_}, $row, $head_idx{$_},
        {validate => 'list', source => "=$field_to_defs{$_}",});
    }

    $NEW_TABLE->();
    $worksheet->conditional_formatting(
      '$A:$A',
      {
        type     => 'formula',
        format   => $green,
        criteria => "=NOT(ISERROR(VLOOKUP(A1,$name_match,1,FALSE)))",
      }
    );

    # CAUTION: hardcoded with "repo" worksheet
    my %fi = (System => 2, Team => 3, Owner => 4);
    my $tn = $TN->($SN->("repo"));
    while (my ($f, $i) = each %fi) {
      my $formula = "=VLOOKUP([[#This Row],[Repo]],$tn,$i,FALSE)";
      $worksheet->write(1, $head_idx{$f}, $formula);
    }
  }

  # "summary" worksheet
  if ($NEED->($sheet = "summary")) {
    $worksheet = $workbook->add_worksheet($SN->($sheet));
  }

  # "file" worksheet
  if ($NEED->($sheet = "file")) {
    @head = qw/ID Repo File Status/;
    @width = (42, 40, 64, 8);

    my %fields;
    @fields{@head} = qw/commit repo file status/;

    $NEW_SHEET->();
    foreach my $repo (sort keys %{$db->{data}}) {
      foreach my $id (@{$db->{data}{$repo}{id}}) {
        my %d = %{$db->{data}{$repo}{data}{$id}};

        for (sort keys %{$d{name_status}}) {
          $d{file}   = $_;
          $d{status} = $d{name_status}->{$_};

          my @l = @d{@fields{@head}};
          eval { $worksheet->write_row($row++, 0, \@l) };
        }
      }
    }
    $NEW_TABLE->();
  }

  # "ticket" worksheet
  if ($NEED->($sheet = "ticket")) {
    @head = qw/ID Ticket/;
    @width = (42, 14);

    $NEW_SHEET->();
    for my $l (sort keys %id_ticket) {
      $worksheet->write_row($row++, 0, [split ',', $l]);
    }
    $NEW_TABLE->();
  }

  # "reviewer" worksheet
  if ($NEED->($sheet = "reviewer")) {
    @head = qw/ID Reviewer/;
    @width = (42, 30);

    $NEW_SHEET->();
    for my $l (sort keys %id_reviewer) {
      $worksheet->write_row($row++, 0, [split ',', $l]);
    }
    $NEW_TABLE->();
  }

  # "match" worksheet
  if ($NEED->($sheet = "match")) {
    my ($this, $that) = @{$db->{meta}{refs}}{qw/this that/};

    @head = ('Repo', $that, $this, 'Reason', 'Factor');
    @width = (40, 42, 42, 10, 42);
    my %fields;
    @fields{@head} = ('repo', $that, $this, 'reason', 'factor');

    $NEW_SHEET->();
    foreach my $repo (sort keys %{$db->{match}}) {
      foreach my $d (@{$db->{match}{$repo}{data}}) {

        my @l = @{$d}{@fields{@head}};
        eval { $worksheet->write_row($row++, 0, \@l) };
      }
    }
    $NEW_TABLE->();

    my $tn = $TN->($sheet);
    $workbook->define_name($name_match, "=$tn\[[$that]:[$this]]");
  }

  # "repo" worksheet
  if ($NEED->($sheet = "repo")) {
    @head = (qw/Repo System Team Name Email/);
    @width = (40, 10, 10, 18, 30);

    $NEW_SHEET->();

    # only list non-empty ones
    my @repos = sort grep { @{$db->{data}{$_}{id}} > 0 } keys %{$db->{data}};
    $worksheet->write_col($row, $col++, \@repos);
    $row = 1 + @repos;
    $NEW_TABLE->();
  }

  # "meta" worksheet
  if ($NEED->($sheet = "meta")) {
    @head = qw/Types Status Priorities Repos Emails Authors References Note/;
    @width = (10, 10, 10, 46, 30, 18, 40, 14);

    my %defs = (
      map({ $_, [] } @head),
      Types      => [sort qw/Defect Feature Enhance Spec Custom Other/],
      Status     => [sort qw/Todo Doing Done Redo Defer Ignore/],
      Priorities => [sort qw/Low Normal High/],
    );

    for my $k (sort keys %{$db->{meta}{refs}}) {
      push @{$defs{References}}, $db->{meta}{refs}{$k};
      push @{$defs{Note}},       $k;
    }
    $defs{Repos} = [sort keys %{$db->{data}}];
    for my $k (sort keys %author_email) {
      push @{$defs{Emails}},  $k;
      push @{$defs{Authors}}, $author_email{$k};
    }

    $NEW_SHEET->();
    foreach (@head) {
      $workbook->define_name($_,
        xl_range_formula($SN->($sheet), $row, scalar @{$defs{$_}}, $col, $col)
      );
      $worksheet->write_col($row, $col++, $defs{$_});
    }
  }
}
