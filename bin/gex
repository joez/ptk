#!/usr/bin/env perl
# author: joe.zheng

use strict;
use warnings;

use FindBin;
use lib "$FindBin::RealBin/../lib";

use Excel::Writer::XLSX;
use Excel::Writer::XLSX::Utility;

use XML::Reader qw/XML::Parsepp/;
use XML::Writer;

use Encode qw/decode/;
use Encode::Guess;

use Git::Repository 'Log';

use Getopt::Long;
use File::Path qw/make_path/;
use File::Basename;
use File::Spec::Functions qw/catdir catfile rel2abs/;
use File::Find 'find';
use File::Temp qw/tempdir/;
use Storable qw/nstore retrieve/;
use Text::ParseWords;
use Digest::MD5 qw/md5_hex/;

use Ptk::Base::Log;
use Ptk::Base::Chdir;

my $log = Ptk::Base::Log->new;

my $script = basename($0);

sub usage {
  print <<"EOF";
NAME
    $script - Manage the Git repos

SYNOPSIS
    $script report-log [<options>] [<src>...]
    $script report-delta [<options>] <this> <that> [<src>...]
    $script report-manifest [<options>] [<src>...]

    $script forall [<options>] [<src>...]
    $script tag-manifest [<options>] <tag> [<src>...]
    $script format-patch [<options>] [<src>...]
    $script match-cherry [<options>] <this> <that> [<src>...]

    $script overlay-manifest [<options>] <this> <that> [<src>...]

    $script find-repo [<src>...]
    $script dump-repo [<options>] [<src>...]

DESCRIPTION
    To manage the Git repos

COMMAND
    $script report-log [-r <root>] [-o <output>] [-q <query>] [<src>...]
      export Git log into spreadsheet
      <query>:  the parameters passed to "git log"
      <output>: spreadsheet file path, default "log.xlsx"
      <src>:    relative git repo paths

    $script report-delta [-r <root>] [-o <output>] [-b <base>] <this>
    <that> [<src>...]
      export commit list need to be integrated from <that> to <this>
      as an spreadsheet
      <output>: spreadsheet file path, default "delta.xlsx"
      <base>:   up to and including <base> are not reported on <that>
      <this>:   working branch
      <that>:   remote branch, mostly upstream
      <src>:    relative Git repo paths

    $script report-manifest [-u <url>] [-m <manifest>] [-o <output>]
    [-q <query>] [<src>...]
      export manifest information into spreadsheet
      <url>:      manifest repo url, default ".repo/manifests"
      <manifest>: alternative manifest, default "default.xml"
      <query>:    same as in "dump-repo"
      <output>:   spreadsheet file path, default "manifest.xlsx"
      <src>:      manifest branches, default as HEAD

    $script forall [-r <root>] [-u <url>] [-m <manifest>]
    [-c <command>] [<src>...]
      run the same shell command in each repo, with cwd as current
      repo's work tree, environment variables are set:
       * REPO_PROJECT:  the name of the project
       * REPO_PATH:     the path of the project
       * REPO_REMOTE:   the name of the remote
       * REPO_LREV:     the revision translated for local usage
       * REPO_RREV:     the revision from the manifest
       * REPO_GROUPS:   the groups from the manifest if exists
       * REPO_UPSTREAM: the upstream from the manifest if exists
      <url>:      manifest repo url, default ".repo/manifests"
      <manifest>: alternative manifest, default "default.xml"
      <command>:  command to run, default is "git status"
      <src>:      relative Git repo paths

    $script tag-manifest [-r <root>] [-u <url>] [-m <manifest>]
    <tag> [<src>...]
      add a tag for each repo given the revision from the manifest
      <url>:      manifest repo url, default ".repo/manifests"
      <manifest>: alternative manifest, default "default.xml"
      <tag>:      tag name to apply
      <src>:      relative Git repo paths

    $script format-patch [-r <root>] [-q <query>] [-o <output>] [<src>...]
      format-patch for each repo into output directory
      <query>:   the parameters for "git format-patch", default is "-1",
                 if it is a file, will be regarded as a commit list, with
                 the format:
                  * text start with "#" regarded as comment
                  * text end with ":" regarded as repo path for the
                    following commits
                  * one commit id for each line with ordered
      <output>:  the output directory, default is "./patch"
      <src>:     relative Git repo paths

    $script match-cherry [-r <root>] <this> <that> [<src>...]
      find out all the original and picked cherries with the same changeset
      (with same patch id), but different commit ids between two branches
      <this>: working branch
      <that>: remote branch, mostly upstream
      <src>:  relative Git repo paths

    $script overlay-manifest <this> <that> [<src>...]
      overlay each Git repo's revision defined in <this> manifest with
      one defined in <that> manifest, generally <that> manifest is a
      snapshot, by this way to pin some Git repo in a stable revision
      <this>: the target manifest
      <that>: the snapshot manifest to be applied
      <src>:  the Git repo paths or names

    $script find-repo [<src>...]
      find valid Git repo in the <src> directories and output the paths,
      it can be used to get the Git repo path list for later usage
      <src>: directories to search, default is "."

    $script dump-repo [-q <query>] [<src>...]
      dump the Git repo paths in the given manifests
      <query>: dump repo matching the query only, the query format is
        queries separated by ',', each query is a key-value pair
        separeated by ':', the key is the attribute of the repo definition
        and the value is a regex to match. e.g. "revision:master"
        prefix with '!' for negative match, e.g. "!group:aosp,path:vendor"
      <src>:   manifests to dump, default is ".repo/manifests/default.xml"

OPTIONS

    -r, --root
      the root directory of the Git repo path, default is "."
      all the Git repo paths are assumed relative to the root

    -u, --url
      the manifest repo url, default is ".repo/manifests"

    -m, --manifest
      the alternative manifest file to use, default is "default.xml"

    -o, --output
      the output file path

    <src>
      the source files or directories

EXAMPLES
    1. $script report-log Ptk
      export all the commit list of "Ptk" to "log.xlsx"

    2. $script dump-repo
      dump all the git repo paths in the default manifest at
      ".repo/manifests/default.xml"

    3. $script dump-repo -q 'groups:device,revision:master' default.xml
      dump all the git repo paths in the default manifest "default.xml"
      with "groups" matches "device" AND "revision" matches "master"

    4. $script dump-repo | xargs $script report-log -o all.xlsx
      export all the commits of repos in default manifest to "all.xlsx"

    5. $script find-repo > repo-list.txt
      find out all the valid Git repo paths in the current directory
      and redirect to repo-list.txt for later usage

    6. $script report-log -q 'develop..upstream' repo-list.txt
      export the commit list between "develop" and "upsteam" branches,
      of the Git repos in the "repo-list.txt", and export to "log.xlsx"

    7. $script forall Ptk
      run "git status" in Git repo "Ptk"

    8. $script forall -c 'git pull --rebase' repo-list.txt
      run "git pull --rebase" in Git repos in "repo-list.txt"

    9. $script match-cherry develop upstream repo-list.txt
      find all the commit with same changeset but different commit id,
      between "develop" and "upstream" of Git repos in "repo-list.txt"

    10. $script report-delta develop upstream repo-list.txt
      export all the commit list only exist in the "upstream" branch of
      Git repos in "repo-list.txt" into "delta.xlsx", these commits
      need to be cherry-picked

    11. $script format-patch -q BASE..HEAD repo-list.txt
      format-patch from BASE to HEAD for each repo in repo-list.txt,
      save the patches into "./patch" folder

    12. $script format-patch -q commit-list.txt -o exported-patch
      export the patch according to the definition in the commit-list.txt
      save the patches into "exported-patch" folder

    13. $script overlay-manifest default.xml snapshot.xml repo-list.txt
      overlay repo's revision defined in default.xml with one defined in
      snapshot.xml, only the repo name in "repo-list.txt" is applied

    14. $script tag-manifest -u . -m pin.xml TAG_FOR_TEST repo-list.txt
      add a tag named TAG_FOR_TEST for each repo listed in repo-list.txt
      based on the revision defined from pin.xml

NOTES
    * all the Git repo paths are assumed relative to the root,
      if a path pointing to a existing file, it will be regarded as a
      file containing a path list

SEE ALSO

EOF

  exit;
}

my %opt = (
  root     => '.',
  query    => '',
  base     => '',
  url      => '.repo/manifests',
  manifest => 'default.xml',
  output   => '',
  command  => ''
);

my $help;
GetOptions(
  "help|h"       => \$help,
  "root|r=s"     => \$opt{root},
  "query|q=s"    => \$opt{query},
  "base|b=s"     => \$opt{base},
  "url|u=s"      => \$opt{url},
  "manifest|m=s" => \$opt{manifest},
  "command|c=s"  => \$opt{command},
  "output|o=s"   => \$opt{output},
) or usage();

my $cmd = lc(shift || '');
usage() if $help || !$cmd;

my %cmdcbs = (
  "report-log"       => \&do_report_log,
  "report-delta"     => \&do_report_delta,
  "report-manifest"  => \&do_report_manifest,
  "find-repo"        => \&do_find_repo,
  "dump-repo"        => \&do_dump_repo,
  "match-cherry"     => \&do_match_cherry,
  "forall"           => \&do_forall,
  "tag-manifest"     => \&do_tag_manifest,
  "format-patch"     => \&do_format_patch,
  "overlay-manifest" => \&do_overlay_manifest,
);

my $cb = $cmdcbs{$cmd};
if ($cb) {
  $cb->(@ARGV);
}
else {
  warn 'no such command';
  usage();
}


# subs


sub resolve_list {
  my @list;

  foreach my $p (@_) {
    if (-e $p && -f $p) {
      open my $fh, '<', $p or die;
      while (<$fh>) {
        chomp;
        s/#.*//;
        s/^\s+//;
        s/\s+$//;
        next unless $_;

        push @list, $_;
      }
      close $fh;
    }
    else {
      push @list, $p;
    }
  }

  return @list;
}

sub resolve_path {
  wantarray ? map { catfile($opt{root}, $_) } @_ : catfile($opt{root}, shift);
}

sub correct_sheet_name {
  my $n = shift;
  if (length $n) {

    # no more than 31, and no special chars
    if (length $n > 31) {
      $n = join('-', substr(md5_hex($n), -4), substr($n, -26));
    }
    $n =~ s|[\[\]\*\?:/\\]|.|g;
  }
  return $n;
}

sub correct_var_name {
  my $n = shift;
  $n =~ s/^\d+//;
  $n =~ s/[^0-9a-zA-Z]/_/g;
  return join('', map { +ucfirst } split(/_+/, $n));
}

sub get_temp_dir { return tempdir(CLEANUP => 1) }

sub checkout_to {
  my $dir = shift or die;
  my $url = shift or die;
  my $rev = shift || '';

  my $git_dir = catfile($dir, '.git');
  Git::Repository->run(qw/clone --mirror -s/, $url, $git_dir);

  my $r = Git::Repository->new(git_dir => $git_dir, work_tree => $dir);
  return $r->run(qw/reset --hard/, $rev);
}

sub do_report_manifest {
  my @revs = @_;
  unshift @revs, 'HEAD' unless @revs;

  my $dst      = $opt{output} || 'manifest.xlsx';
  my $url      = $opt{url};
  my $manifest = $opt{manifest};
  my $query    = $opt{query};

  my $q  = resolve_query($query);
  my $db = {};
  $db->{meta}{$_} = {} for qw/path remote fetch review revs/;
  $db->{meta}{info}{query}    = $query;
  $db->{meta}{info}{manifest} = $manifest;
  $db->{meta}{info}{revision} = join ', ', @revs;

  for my $rev (@revs) {
    $log->info("processing: $rev");

    my $dir = get_temp_dir();
    checkout_to($dir, $url, $rev);

    my $f = catfile($dir, $manifest);
    my $m = parse_manifest($f);
    for my $n (sort +get_project_list($m)) {
      my $r = get_resolved_project($m, $n);
      if (match_repo($r, $q)) {
        my $p = $r->{path};
        $db->{data}{$rev}{$p} = $r;

        $db->{meta}{$_}{$r->{$_}}++ for qw/path remote fetch review/;
      }
    }
    $db->{meta}{revs}{$rev}++ if exists $db->{data}{$rev};
  }

  for my $rev (keys %{$db->{meta}{revs}}) {
    for my $p (keys %{$db->{meta}{path}}) {
      $db->{revision}{$p}{$rev} = '';
      if (exists $db->{data}{$rev} && exists $db->{data}{$rev}{$p}) {
        $db->{revision}{$p}{$rev} = $db->{data}{$rev}{$p}{revision};
      }
    }
  }

  repo_to_xls($dst, $db);
}

sub repo_to_xls {
  my $dst = shift or die;
  my $db  = shift or die;

  my @revs       = sort keys %{$db->{meta}{revs}};
  my @sheets     = (@revs, qw/summary revision meta/);
  my %sheet_name = map { ($_, $_) } @sheets;
  my %sheet_need = map { ($_, 1) } @sheets;

  $sheet_need{revision} = @revs > 1;

  my $workbook = Excel::Writer::XLSX->new($dst);
  my $bold     = $workbook->add_format(bold => 1, align => 'center');
  my $green    = $workbook->add_format(bg_color => '#A4D050');
  my ($sheet, $worksheet);
  my ($row,   $col);
  my (@head,  @width);

  my $SN = sub { correct_sheet_name($sheet_name{$_[0]}) };
  my $TN = sub { 'Tb' . correct_var_name($SN->($_[0])) };
  my $NEW_SHEET = sub {
    ($row, $col) = (0, 0);
    $worksheet = $workbook->add_worksheet($SN->($sheet));
    $worksheet->freeze_panes(1, 0);
    $worksheet->set_column($_, $_, $width[$_]) for 0 .. $#width;
    $worksheet->write_row($row++, 0, \@head, $bold);
  };
  my $NEW_TABLE = sub {
    my $n = $TN->($sheet);
    my @c = map { +{header => $_} } @head;

    $worksheet->add_table(0, 0, $row > 1 ? $row - 1 : 1,
      $#head, {style => 'Table Style Light 1', columns => \@c, name => $n,});
  };

  my $NEED = sub { $sheet_need{+shift} };

  # "revision" worksheet
  if ($NEED->($sheet = "revision")) {
    my @info = (qw/Path/, @revs);
    @head = (@info, qw/Note/);
    @width = (40, ((30) x @revs), 20);
    my %fields;
    @fields{@info} = @info;
    $fields{Path} = 'path';

    my %head_idx;
    {
      my $i;
      %head_idx = map +($_, $i++), @head;
    }

    $NEW_SHEET->();

    for my $p (sort keys %{$db->{meta}{path}}) {
      my %d = %{$db->{revision}{$p}};
      $d{path} = $p;

      my @l = @d{@fields{@info}};
      eval { $worksheet->write_row($row++, 0, \@l) };
    }

    $NEW_TABLE->();
  }

  # "summary" worksheet
  if ($NEED->($sheet = "summary")) {
    $worksheet = $workbook->add_worksheet($SN->($sheet));
  }

  for my $rev (@revs) {
    if ($NEED->($sheet = $rev)) {
      my @info = qw/Path Revision Name Fetch Review Groups/;
      @head = (@info, qw/Note/);
      @width = (40, 30, 30, 30, 30, 20, 20);
      my %fields;
      @fields{@info} = qw/path revision name fetch review groups/;
      my %head_idx;
      {
        my $i;
        %head_idx = map +($_, $i++), @head;
      }

      $NEW_SHEET->();

      foreach my $p (sort keys %{$db->{data}{$rev}}) {
        my %d = %{$db->{data}{$rev}{$p}};

        my @l = @d{@fields{@info}};
        eval { $worksheet->write_row($row++, 0, \@l) };
      }

      $NEW_TABLE->();
    }
  }

  # "meta" worksheet
  if ($NEED->($sheet = "meta")) {
    @head
      = qw/Status Priorities Repos Remotes Fetches Reviews Parameters Values/;
    @width = (10, 10, 40, 10, 30, 30, 20, 20);

    my %defs = (
      map({ $_, [] } @head),
      Status     => [sort qw/Todo Doing Done Redo Hold Never/],
      Priorities => [sort qw/Low Normal High/],
    );

    $defs{Repos}   = [sort keys %{$db->{meta}{path}}];
    $defs{Remotes} = [sort keys %{$db->{meta}{remote}}];
    $defs{Fetches} = [sort keys %{$db->{meta}{fetch}}];
    $defs{Reviews} = [sort keys %{$db->{meta}{review}}];
    for my $k (sort keys %{$db->{meta}{info}}) {
      push @{$defs{Values}},     $db->{meta}{info}{$k};
      push @{$defs{Parameters}}, $k;
    }

    $NEW_SHEET->();
    foreach (@head) {
      $workbook->define_name($_,
        xl_range_formula($SN->($sheet), $row, scalar @{$defs{$_}}, $col, $col)
      );
      $worksheet->write_col($row, $col++, $defs{$_});
    }
  }
}

sub do_find_repo {
  my @dirs = @_;
  unshift @dirs, '.' unless @dirs;

  my %seen;

  my $sub_wanted = sub {
    if (-d $_) {
      if (/\.git$/ || -e catfile($_, '.git')) {
        $seen{$File::Find::name}++;
        $File::Find::prune = 1;
        $log->info($File::Find::name);
      }
    }
  };
  my $sub_preprocess = sub {
    return grep { /^\.git$/ || !/^\./ } @_;
  };

  find({wanted => $sub_wanted, preprocess => $sub_preprocess}, $_)
    foreach @dirs;

  local $\ = "\n";
  print $_ foreach sort keys %seen;
}

sub get_project_list { @{$_[0]->{project}{seen}} }

sub get_project {
  my $db = shift or die;
  my $pn = shift or die;

  # first by name, then by path
  my $r;
  if (exists $db->{project}{data}{$pn}) {
    $r = $db->{project}{data}{$pn};
  }
  elsif (exists $db->{project}{name}{$pn}) {
    my $n = $db->{project}{name}{$pn};
    $r = $db->{project}{data}{$n};
  }

  return $r;
}

sub get_resolved_project {
  my $db = shift or die;
  my $pn = shift or die;

  my $p = get_project($db, $pn);
  return $p unless $p;

  my $d = $db->{default};

  my $rn = $p->{remote} || $d->{remote};
  my $r = $db->{remote}{$rn};

  return {%$d, %$r, %$p};
}

sub resolve_query {
  my @queries = ();

  for (@_) {
    chomp;
    my @query = ();

    for (split /\s*[,]\s*/) {
      my ($k, $v) = split /[:]/;
      my $reverse = ($k =~ s/^!\s*//);

      my $item = {k => $k, q => qr/$v/i, r => $reverse,};
      push @query, $item;
    }

    push @queries, \@query;
  }

  return \@queries;
}

sub match_repo {
  my $repo    = shift or die;
  my $queries = shift or die;

  # there are multiple query items in the $query
  # if one of the items match, the result is true
  # if all the items fail to match, the result is false
  #
  # for each item, there are multiple keys to match
  # if one of the key is not match, the whole item fails
ITEM: for my $query (@$queries) {
    for my $item (@$query) {
      my ($k, $q, $r) = @{$item}{qw/k q r/};
      my $v = $repo->{$k} || '';

      next ITEM unless ($r ? $v !~ $q : $v =~ $q);
    }
    return 1;
  }

  return @$queries ? 0 : 1;
}

sub do_dump_repo {
  my @manifests = @_;
  unshift @manifests, catfile(@opt{qw/url manifest/}) unless @manifests;

  my $query = $opt{query} || '';

  my $q = resolve_query($query);

  local $\ = "\n";
  for my $m (@manifests) {
    my $db = parse_manifest($m);

    for my $n (sort +get_project_list($db)) {
      my $r = get_resolved_project($db, $n);
      print $r->{path} if match_repo($r, $q);
    }
  }
}

sub get_local_rev {
  my $rev = shift or die;
  my $remote = shift || '';

  for ($rev) {
    unless (/^HEAD$/ or m|^refs/| or /^[0-9a-f]{40}$/) {
      $rev = join('/', length $remote ? $remote : 'origin', $rev);
    }
  }
  return $rev;
}

sub do_forall {
  my $cmd = $opt{command} || 'git status';
  my @repos = resolve_list(@_);

  my $db;
  my $manifest = catfile(@opt{qw/url manifest/});
  if (-e $manifest) {
    $db = parse_manifest($manifest);
  }
  else {
    $log->warn("can't access manifest: $manifest");
  }

  my %done;
  my ($ttl, $cnt) = (scalar(@repos), 1);
  for my $repo (@repos) {
    $log->info("[$cnt / $ttl] processing: $repo");
    $cnt++;
    print "#-- project: $repo\n";

    my $path    = resolve_path($repo);
    my $git_dir = $path =~ /\.git$/ ? '.' : '.git';
    my $env     = {GIT_DIR => $git_dir, REPO_PATH => $repo};

    if ($db) {
      if (my $d = get_resolved_project($db, $repo)) {
        $env->{REPO_PROJECT} = $d->{name};
        $env->{REPO_REMOTE}  = $d->{remote};
        $env->{REPO_RREV}    = $d->{revision};
        $env->{REPO_LREV}
          = get_local_rev($d->{revision}, $d->{remote} || $d->{alias});
        $env->{REPO_GROUPS}   = $d->{groups}   if exists $d->{groups};
        $env->{REPO_UPSTREAM} = $d->{upstream} if exists $d->{upstream};
      }
      else {
        $log->warn("can't find repo in manifest: $repo");
      }
    }
    $log->debug($env);

    eval {
      my $chdir = Ptk::Base::Chdir->new;
      unless ($chdir->pushd($path)) {
        $log->warn("fail to access $path, skip: $repo");
      }
      else {
        local %ENV = (%ENV, %$env);

        if (system($cmd)) {
          $log->warn("fail to process: $repo");
        }
        else {
          $done{$repo}++;
        }
      }
    };
  }

  print <<EOF;
#-- DONE
Total $ttl projects processed
EOF

  my @fail = grep { !exists $done{$_} } @repos;
  print 'Total ', scalar @fail, ' projects are failed:', "\n";
  print join("\n", @fail), "\n";
}

sub do_tag_manifest {
  my $name = shift or usage();

  # hack here
  $opt{command} = "git tag $name \$REPO_LREV";

  do_forall(@_);
}

sub parse_commit_list {
  my %db;

  my $re_id  = qr/^([\da-f]{6,40})\b/;
  my $re_dir = qr/^\[?(.+?)\]?:$/;

  my $dir = '.';
  foreach my $p (@_) {
    if (-e $p && -f $p) {
      open my $fh, '<', $p or die;
      while (<$fh>) {
        chomp;
        s/#.*//;
        s/^\s+//;
        s/\s+$//;
        next unless $_;

        if (/$re_dir/) {
          $dir = $1;
        }
        elsif (/$re_id/) {
          $db{$dir}{data}{$1} = $_;
          push @{$db{$dir}{id}}, $1;
        }
      }
      close $fh;
    }
    else {
      $log->warn("can not accesss, skip: $p");
    }
  }

  return \%db;
}

sub do_format_patch {
  my $output = $opt{output} || 'patch';
  my $query  = $opt{query}  || '-1';
  my @repos  = resolve_list(@_);
  my $root   = $opt{root}   || '.';

  # if the query is a file, regard it as commit list
  my $db;
  if (-e $query && -f $query) {
    $log->info("commit list: $query");
    $db = parse_commit_list($query);

    # if no repos provided, export all repos in commit list
    push @repos, sort keys %$db unless @repos;
  }

  my ($ttl, $cnt) = (scalar(@repos), 1);
  for my $repo (@repos) {
    $log->info("[$cnt / $ttl] processing: $repo");
    $cnt++;

    my $source = catdir($root, $repo);
    my $target = rel2abs(catdir($output, $repo));

    unless (-e $source) {
      $log->warn("not exist, skip: $source");
    }
    else {
      $log->info("output: $target");
      make_path($target) unless -e $target;

      my $git_dir = $source;
      for ($git_dir) {
        $git_dir = catdir($git_dir, '.git') unless /\.git$/;
      }
      my $r = Git::Repository->new(git_dir => $git_dir);

      if ($db) {
        if (exists $db->{$repo}) {
          my $i = 1;
          for my $id (@{$db->{$repo}{id}}) {
            $log->info('processing: ' . $db->{$repo}{data}{$id});
            print "$_\n"
              for $r->run('format-patch', '-o', $target, '--start-number',
              $i++, '-1', $id);
          }
        }
        else {
          $log->warn("not defined in commit list, skip: $source");
        }
      }
      else {
        print "$_\n" for $r->run('format-patch', '-o', $target, '-q', $query);
      }
    }
  }
}

sub do_overlay_manifest {
  my $this = shift or die;
  die "cannot write file: $this" unless -w $this;
  my $that = shift or die;
  die "cannot read file: $that" unless -r $that;

  my %wanted = map { ($_ => 1) } resolve_list(@_);

  my $da = parse_manifest($this);
  my $db = parse_manifest($that);

  local @ARGV = ($this, @{$da->{include}{seen}});
  local $^I = '';
  while (<>) {
    if (/name="(.+?)"/ or /path="(.+?)"/) {
      my $n = $1;
      my $d = get_resolved_project($db, $n);
      if ($wanted{$n} && $d) {
        my $rev = $d->{revision};

        $log->debug("overlay $n revision to $rev");
        unless (s/revision="(.+?)"/revision="$rev"/) {
          s|\s*?(/?>)\s*?$| revision="$rev" $1|;
        }
      }
    }
    print;
  }
}

sub check_match_cherry {
  my $dr   = shift;    # { id => {} }
  my $this = shift;
  my $that = shift;
  my $factor = shift || [qw/patch_id change_id origin_id ticket_id subject/];

  my $repo;
  my $o = {data => [],};

  for my $id (keys %$dr) {
    my $d = $dr->{$id};
    my $s = $d->{branch};

    $repo = $d->{repo} unless $repo;

    push @{$o->{change_id}{$_}{$s}}, $id for @{$d->{change_ids}};
    push @{$o->{origin_id}{$_}{$s}}, $id for @{$d->{origin_ids}};
    push @{$o->{ticket_id}{$_}{$s}}, $id for @{$d->{ticket_ids}};
    for (qw/patch_id subject/) {
      push @{$o->{$_}{$d->{$_}}{$s}}, $id if $d->{$_};
    }
  }

  my %seen;

  for my $reason (@$factor) {
    next unless exists $o->{$reason};

    for my $id (keys %{$o->{$reason}}) {
      my $r = $o->{$reason}{$id};

      if ($reason eq 'origin_id') {
        if (exists $dr->{$id}) {
          my $swap = $dr->{$id}{branch} eq $that;
          my $other = $swap ? $this : $that;

          my $a = $id;
          if (exists $r->{$other}) {
            for (@{$r->{$other}}) {
              my $b = $_;
              my $ab = $swap ? $b . $a : $a . $b;

              next if exists $seen{$ab};
              $seen{$ab}++;

              push @{$o->{data}},
                {
                repo => $repo,
                $this => $swap ? $b : $a,
                $that => $swap ? $a : $b,
                reason => $reason,
                factor => $id,
                };
            }
          }
        }
      }

      if (exists $r->{$this} && exists $r->{$that}) {
        for my $a (@{$r->{$this}}) {
          for my $b (@{$r->{$that}}) {
            my $ab = $a . $b;
            next if exists $seen{$ab};
            $seen{$ab}++;
            push @{$o->{data}},
              {
              repo   => $repo,
              $this  => $a,
              $that  => $b,
              reason => $reason,
              factor => $id,
              };
          }
        }
      }
    }
  }

  return $o;
}

sub do_match_cherry {
  my $this = shift or usage();
  my $that = shift or usage();

  my $db    = {};
  my @repos = resolve_list(@_);

  my ($ttl, $cnt) = (scalar(@repos), 1);
  for my $repo (@repos) {
    my $dr = $db->{$repo} || {};
    $db->{$repo} = $dr;

    $log->info("[$cnt / $ttl] processing: $repo");
    $cnt++;

    for my $path (grep {-e} resolve_path($repo)) {
      for ($path) {
        $path = catdir($path, '.git') unless /\.git$/;
      }
      eval {
        my $r = Git::Repository->new(git_dir => $path);
        my $a = $r->run(qw/rev-parse --verify/, $this);
        my $b = $r->run(qw/rev-parse --verify/, $that);

        for ($r->run(qw/rev-list --no-merges --left-right/, "$a...$b")) {
          $log->debug($_);
          my $side = substr($_, 0, 1) eq '<' ? $this : $that;
          my $id = substr $_, 1;

          my $d = get_commit_info(git_log($r, "-1", $id)->next);
          $d->{branch} = $side;
          $d->{repo}   = $repo;

          # compare patch-id
          $d->{patch_id} = get_patch_id($r, $id);

          $dr->{$id} = $d;
        }
      };
    }
  }

  local $\ = "\n";
  my $sep = "\t";
  my @head = ('Repo', $this, $that, 'Reason', 'Factor');
  my %fields;
  @fields{@head} = ('repo', $this, $that, 'reason', 'factor');

  print join($sep, @head);

  for my $repo (sort keys %$db) {
    my $dr = $db->{$repo};

    my $m = check_match_cherry($dr, $this, $that);
    for my $d (@{$m->{data}}) {
      print join($sep, @{$d}{@fields{@head}});
    }
  }
}

sub do_report_log {
  my $dst = $opt{output} || 'log.xlsx';

  my $db = {};
  $db->{meta}{refs}{query} = $opt{query};

  my @repos = resolve_list(@_);
  my ($ttl, $cnt) = (scalar(@repos), 1);
  for my $p (@repos) {
    $log->info("[$cnt / $ttl] processing: $p");
    $cnt++;

    parse_repo_log($db, $_, $p) for grep {-e} resolve_path($p);
  }

  db_to_xls($dst, $db);
}

sub do_report_delta {
  my $this = shift or usage();
  my $that = shift or usage();
  my $base = $opt{base};

  my $dst = $opt{output} || 'delta.xlsx';

  my $db = {};
  $db->{meta}{refs}{base} = $base;
  $db->{meta}{refs}{this} = $this;
  $db->{meta}{refs}{that} = $that;

  my @repos = resolve_list(@_);
  my ($ttl, $cnt) = (scalar(@repos), 1);
  for my $p (@repos) {
    $log->info("[$cnt / $ttl] processing: $p");
    $cnt++;

    parse_repo_delta($db, $_, $p, $this, $that, $base)
      for grep {-e} resolve_path($p);
  }

  db_to_xls($dst, $db);
}

sub parse_repo_log {
  my $db   = shift or die;
  my $path = shift or die;
  my $repo = shift or die;
  my $query = $opt{query} || '--';

  for ($path) {
    $path = catdir($path, '.git') unless /\.git$/;
  }
  eval {
    my $r = Git::Repository->new(git_dir => $path);
    my $i = git_log($r, shellwords $opt{query});

    $log->info($path, $opt{query});
    while (my $l = $i->next) {
      my $d = get_commit_info($l);
      $d->{repo} = $repo;
      $log->info($d->{commit});

      push @{$db->{data}{$repo}{id}}, $d->{commit};
      $db->{data}{$repo}{data}{$d->{commit}} = $d;
    }
  };
}

sub get_patch_id {
  my $repo = shift;
  my $id   = shift;

  my $cmd = $repo->command('patch-id');
  my $fi  = $cmd->stdin;
  my $fo  = $cmd->stdout;

  my $fd = $repo->command('show', $id)->stdout;
  while (<$fd>) {
    print $fi $_;
  }
  close $fd;

  my $patch_id = (split ' ', <$fo>)[0];
  $cmd->close;

  return $patch_id;
}


sub parse_commit_message {
  my $m = shift;
  my $d = {};

  foreach (split "\n", $m) {
    chomp;
    next unless $_;

    # previous value may be overriden, just get the latest one
    if (/^Change-Id:\s+(I[\da-f]{40})$/) {
      push @{$d->{change_ids}}, $1;
      $d->{change_id} = $1;
      next;
    }
    if (/^Reviewed-on:\s+.+\/(\d+)$/) {
      push @{$d->{request_ids}}, $1;
      $d->{request_id} = $1;
      next;
    }
    if (/^\(cherry picked from commit ([\da-f]{40})$/) {
      push @{$d->{origin_ids}}, $1;
      $d->{origin_id} = $1;
      next;
    }

    if (/^Reviewed-by:\s+[^<]+<(([^@]+)@[\w.]+)>$/) {
      push @{$d->{reviewers}}, $1 unless $2 =~ /_noreply/;
      next;
    }

    if (/^(?:BZ):\s*([\d\s]+)$/) {
      for (split /\s/, $1) {
        if (/(\d+)/) {
          push @{$d->{ticket_ids}}, $1;
        }
      }
      next;
    }

    if (/^(?:Bug|Issue|UTP-Id):\s*(.+)$/) {
      for (split /\s/, $1) {
        if (/([A-Z-]*\d+)/) {
          push @{$d->{ticket_ids}}, $1;
        }
      }
      next;
    }

  }

  $log->debug($d);

  return $d;
}

sub parse_commit_extra {
  my $m = shift;
  my $d = {};

  foreach (split "\n", $m) {
    chomp;
    next unless $_;

    # files and status, see git log --name-status
    if (/^([ACDMRTUXB]+)\s+(.+)$/) {
      $d->{name_status}{$2} = $1;
    }
  }

  $log->debug($d);

  return $d;
}

sub git_log { shift->log('--name-status' => @_) }

sub get_commit_info {
  my $l = shift;

  my $d = {};
  $d = {
    commit          => $l->commit,
    author_name     => $l->author_name,
    author_email    => $l->author_email,
    author_time     => $l->author_localtime,
    committer_name  => $l->committer_name,
    committer_email => $l->committer_email,
    committer_time  => $l->committer_localtime,
    subject         => $l->subject,
    body            => $l->body,
    %{parse_commit_message($l->body)}, %{parse_commit_extra($l->extra)},
    }
    if $l;

  return $d;
}

sub parse_repo_delta {
  my $db   = shift or die;
  my $path = shift or die;
  my $repo = shift or die;
  my $this = shift or die;
  my $that = shift or die;
  my $base = shift || '';

  for ($path) {
    $path = catdir($path, '.git') unless /\.git$/;
  }
  eval {
    my $r = Git::Repository->new(git_dir => $path);
    $log->info($path, $this, $that);
    my $m = {};

    for ($r->run(shellwords "cherry $this $that $base")) {
      if (/^\+\s*(.+)$/) {
        my $id = $1;

        $log->info($id);

        my $d = get_commit_info(git_log($r, "-1", $id)->next);
        $d->{repo}   = $repo;
        $d->{branch} = $that;

        push @{$db->{data}{$repo}{id}}, $id;
        $db->{data}{$repo}{data}{$id} = $d;

        $m->{$id} = $d;
      }
    }

    for ($r->run(qw/rev-list --no-merges --left-only/, "$this...$that")) {
      my $id = $_;

      my $d = get_commit_info(git_log($r, "-1", $id)->next);
      $d->{branch} = $this;
      $d->{repo}   = $repo;

      $m->{$id} = $d;
    }

    my $f = [qw/change_id origin_id ticket_id subject/];
    $db->{match}{$repo} = check_match_cherry($m, $this, $that, $f);
  };
}

sub parse_manifest {
  my $manifest = shift or die;
  my $db = shift || {include => {seen => []}, project => {seen => []}};

  $log->debug('parse manifest: ' . $manifest);
  unless (-e $manifest) {
    $log->warn("can't access manifest: $manifest");
    return $db;
  }

  my %xpath = (
    manifest         => '/manifest',
    remote           => '/manifest/remote',
    include          => '/manifest/include',
    default          => '/manifest/default',
    project          => '/manifest/project',
    'remove-project' => '/manifest/remove-project',
  );
  my $rdr = XML::Reader->new($manifest, {mode => 'attr-in-hash'});

  while ($rdr->iterate) {
    if ($rdr->is_start) {
      my $path = $rdr->path;
      my $attr = $rdr->att_hash;

      if ($path eq $xpath{include}) {
        if ($attr->{name}) {
          my $m = catfile(dirname($manifest), $attr->{name});
          push @{$db->{include}{seen}}, $m;

          # parse included manifest
          parse_manifest($m, $db);
        }
      }
      elsif ($path eq $xpath{remote}) {
        $db->{remote}{$attr->{name}} = $attr;
      }
      elsif ($path eq $xpath{default}) {
        $db->{default} = $attr;
      }
      elsif ($path eq $xpath{project}) {
        $db->{project}{data}{$attr->{name}} = $attr;
        push @{$db->{project}{seen}}, $attr->{name};
      }
      elsif ($path eq $xpath{'remove-project'}) {
        my $n = $attr->{name};
        if (exists $db->{project}{data}{$n}) {
          $log->debug("project removed: $n");
          $db->{removed}{$n} = delete $db->{project}{data}{$n};
          $db->{project}{seen} = [grep { $_ ne $n } @{$db->{project}{seen}}];
        }
        else {
          $log->warn("cannot find project to be removed: $n");
        }
      }
      else {
        $log->debug('skip node: ' . $rdr->path);
      }
    }
    if ($rdr->is_text) {
    }

    if ($rdr->is_end) {
    }
  }

  # path to name mapping
  for my $v (values %{$db->{project}{data}}) {

    # there is no "path" defined for mirror project
    $v->{path} = $v->{name} unless $v->{path};
    $db->{project}{name}{$v->{path}} = $v->{name};
  }

  return $db;
}

sub format_date {
  my ($sec, $min, $hour, $mday, $mon, $year) = localtime(shift);
  return sprintf '%04d-%02d-%02d', $year + 1900, $mon + 1, $mday;
}

sub db_to_xls {
  my $dst = shift or die;
  my $db  = shift or die;

  my @sheets     = qw/data summary file ticket reviewer match integrator meta/;
  my %sheet_name = map { ($_, $_) } @sheets;
  my %sheet_need = map { ($_, 1) } @sheets;

  $sheet_need{match} = exists $db->{match};

  my %author_email;
  my %id_ticket;
  my %id_reviewer;
  my $name_match = 'MatchedCherries';

  my $workbook = Excel::Writer::XLSX->new($dst);
  my $bold     = $workbook->add_format(bold => 1, align => 'center');
  my $green    = $workbook->add_format(bg_color => '#A4D050');
  my ($sheet, $worksheet);
  my ($row,   $col);
  my (@head,  @width);

  my $SN = sub { correct_sheet_name($sheet_name{$_[0]}) };
  my $TN = sub { 'Tb' . correct_var_name($SN->($_[0])) };
  my $NEW_SHEET = sub {
    ($row, $col) = (0, 0);
    $worksheet = $workbook->add_worksheet($SN->($sheet));
    $worksheet->freeze_panes(1, 0);
    $worksheet->set_column($_, $_, $width[$_]) for 0 .. $#width;
    $worksheet->write_row($row++, 0, \@head, $bold);
  };
  my $NEW_TABLE = sub {
    my $n = $TN->($sheet);
    my @c = map { +{header => $_} } @head;

    $worksheet->add_table(0, 0, $row > 1 ? $row - 1 : 1,
      $#head, {style => 'Table Style Light 1', columns => \@c, name => $n,});
  };

  my $NEED = sub { $sheet_need{+shift} };

  # "data" worksheet
  if ($NEED->($sheet = "data")) {
    my @info = qw/ID Author Email Subject Repo Committer Date Gerrit/;
    @head = (@info, qw/Status Type Integrator Note/);
    @width = (42, 18, 30, 56, 46, 18, 10, 8, 8, 8, 10, 14);
    my %fields;
    @fields{@info}
      = qw/commit author_name author_email subject repo committer_name committer_time request_id/;
    my %head_idx;
    {
      my $i;
      %head_idx = map +($_, $i++), @head;
    }

    $NEW_SHEET->();

    foreach my $repo (sort keys %{$db->{data}}) {
      foreach my $id (@{$db->{data}{$repo}{id}}) {
        my %d = %{$db->{data}{$repo}{data}{$id}};

        $author_email{$d{author_email}} = $d{author_name};
        for (@{$d{ticket_ids}}) {
          my $l = join ',', $id, $_;
          $id_ticket{$l}++;
        }
        for (@{$d{reviewers}}) {
          my $l = join ',', $id, $_;
          $id_reviewer{$l}++;
        }

        $d{committer_time} = format_date($d{committer_time});
        my @l = @d{@fields{@info}};
        eval { $worksheet->write_row($row++, 0, \@l) };
      }
    }

    my %field_to_defs = (Status => 'Status', Type => 'Types');
    foreach (qw/Status Type/) {
      $worksheet->data_validation(1, $head_idx{$_}, $row, $head_idx{$_},
        {validate => 'list', source => "=$field_to_defs{$_}",});
    }

    $NEW_TABLE->();
    $worksheet->conditional_formatting(
      '$A:$A',
      {
        type     => 'formula',
        format   => $green,
        criteria => "=NOT(ISERROR(VLOOKUP(A1,$name_match,1,FALSE)))",
      }
    );

    # CAUTION: the "Repo" column name is hardcoded
    my $formula
      = '=VLOOKUP([[#This Row],[Repo]],'
      . $TN->($SN->("integrator"))
      . ',3,FALSE)';
    $worksheet->write(1, $head_idx{Integrator}, $formula);
  }

  # "summary" worksheet
  if ($NEED->($sheet = "summary")) {
    $worksheet = $workbook->add_worksheet($SN->($sheet));
  }

  # "file" worksheet
  if ($NEED->($sheet = "file")) {
    @head = qw/ID Repo File Status/;
    @width = (42, 46, 64, 8);

    my %fields;
    @fields{@head} = qw/commit repo file status/;

    $NEW_SHEET->();
    foreach my $repo (sort keys %{$db->{data}}) {
      foreach my $id (@{$db->{data}{$repo}{id}}) {
        my %d = %{$db->{data}{$repo}{data}{$id}};

        for (sort keys %{$d{name_status}}) {
          $d{file}   = $_;
          $d{status} = $d{name_status}->{$_};

          my @l = @d{@fields{@head}};
          eval { $worksheet->write_row($row++, 0, \@l) };
        }
      }
    }
    $NEW_TABLE->();
  }

  # "ticket" worksheet
  if ($NEED->($sheet = "ticket")) {
    @head = qw/ID Ticket/;
    @width = (42, 14);

    $NEW_SHEET->();
    for my $l (sort keys %id_ticket) {
      $worksheet->write_row($row++, 0, [split ',', $l]);
    }
    $NEW_TABLE->();
  }

  # "reviewer" worksheet
  if ($NEED->($sheet = "reviewer")) {
    @head = qw/ID Reviewer/;
    @width = (42, 30);

    $NEW_SHEET->();
    for my $l (sort keys %id_reviewer) {
      $worksheet->write_row($row++, 0, [split ',', $l]);
    }
    $NEW_TABLE->();
  }

  # "match" worksheet
  if ($NEED->($sheet = "match")) {
    my ($this, $that) = @{$db->{meta}{refs}}{qw/this that/};

    @head = ('Repo', $that, $this, 'Reason', 'Factor');
    @width = (46, 42, 42, 10, 42);
    my %fields;
    @fields{@head} = ('repo', $that, $this, 'reason', 'factor');

    $NEW_SHEET->();
    foreach my $repo (sort keys %{$db->{match}}) {
      foreach my $d (@{$db->{match}{$repo}{data}}) {

        my @l = @{$d}{@fields{@head}};
        eval { $worksheet->write_row($row++, 0, \@l) };
      }
    }
    $NEW_TABLE->();

    my $tn = $TN->($sheet);
    $workbook->define_name($name_match, "=$tn\[[$that]:[$this]]");
  }

  # "integrator" worksheet
  if ($NEED->($sheet = "integrator")) {
    @head  = ('Repo', 'Email', 'Name');
    @width = (46,     30,      18);

    $NEW_SHEET->();
    my @repos = sort keys %{$db->{data}};
    $worksheet->write_col($row, $col++, \@repos);
    $row = 1 + @repos;
    $NEW_TABLE->();
  }

  # "meta" worksheet
  if ($NEED->($sheet = "meta")) {
    @head = qw/Types Status Priorities Repos Emails Authors References Note/;
    @width = (10, 10, 10, 46, 30, 18, 40, 14);

    my %defs = (
      map({ $_, [] } @head),
      Types      => [sort qw/Defect Feature Enhance Spec Custom Other/],
      Status     => [sort qw/Todo Doing Done Redo Hold Never/],
      Priorities => [sort qw/Low Normal High/],
    );

    for my $k (sort keys %{$db->{meta}{refs}}) {
      push @{$defs{References}}, $db->{meta}{refs}{$k};
      push @{$defs{Note}},       $k;
    }
    $defs{Repos} = [sort keys %{$db->{data}}];
    for my $k (sort keys %author_email) {
      push @{$defs{Emails}},  $k;
      push @{$defs{Authors}}, $author_email{$k};
    }

    $NEW_SHEET->();
    foreach (@head) {
      $workbook->define_name($_,
        xl_range_formula($SN->($sheet), $row, scalar @{$defs{$_}}, $col, $col)
      );
      $worksheet->write_col($row, $col++, $defs{$_});
    }
  }
}
